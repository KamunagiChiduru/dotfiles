snippet		template
abbr		template<T>
	template<typename ${1:T}> 

snippet		class
abbr		class{}
	class ${1:#:name}
	{
		${2}
	};

snippet		try
abbr		try catch
	try
	{
		${1:TARGET}
	}
	catch(${2:#:type}& ${3:e})
	{
		${0}
	}

# lambda expression ( C++11 feature )
snippet		lambda
abbr		[](){}
	[${1}](${2})${3}{ ${4:TARGET} }${0}

# scoped enumeration ( C++11 feature )
snippet		enum_scoped
abbr		enum struct {}
	enum struct { ${1:TARGET} }

# static assert ( C++11 feature )
snippet		static_assert
alias		assert_static
abbr		static_assert(,"")
	static_assert(${1:#:expression}, "${2:#:message}");${0}

delete		namespace
snippet		namespace
abbr		namespace {}
options		head
	namespace ${1:#:name}{
		${0:TARGET}
	} // namespace $1

snippet		if
abbr		if () {}
	if(${1:#:condition})
	{
		${2:TARGET}
	}${0}

snippet else
	else
	{
		${1:TARGET}
	}${0}

snippet elseif
	else if(${1:#:condition})
	{
		${2:TARGET}
	}${0}

snippet		ifelse
abbr		if () {} else {}
	if(${1:#:condition})
	{
		${2:TARGET}
	}
	else
	{
		${3}
	}${0}

snippet		while
abbr		while () {}
	while(${1:#:condition})
	{
		${2:TARGET}
	}${0}

snippet		do_while
alias		do
	do
	{
		${0:TARGET:code}
	}while(${1:#:condition});

snippet		switch
abbr		switch () {}
	switch(${1:#:var}){
		${0}
	}

snippet		function
alias		func
abbr		func() {}
	${1:void} ${2:#:func_name}(${3:#:args})
	{
		${0:TARGET}
	}

snippet		struct
abbr		struct {}
	struct ${1:#:name}
	{
		${0:TARGET:data}
	};

snippet		enum
abbr		enum {}
	enum ${1:#:name}
	{
		${0:TARGET}
	};

# Tertiary conditional
snippet conditional
	(${1:#:condition}) ? ${2:#:a} : ${3:#:b}

# Typedef
snippet typedef
	typedef ${1:#:base_type} ${2:#:custom_type};

snippet printf
abbr	printf("...\n", ...);
	printf("${1}\n", ${2});

snippet fprintf
alias   printerr
abbr	fprintf(..., "...\n", ...);
	fprintf(${1:stderr}, "${2}\n"${3});

snippet comment
alias /*
	/* ${1:#:comment} */
	${0}

snippet sizeof
alias size
	sizeof(${0:TARGET})


